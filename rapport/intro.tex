\documentclass[11pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage[many]{tcolorbox}
\geometry{margin=2.5cm}

\tcbset{
  mydefstyle/.style={
    colback=white,
    colframe=black,
    fonttitle=\bfseries,
    boxrule=0.8pt,
    arc=4pt,
    left=3mm, right=3mm, top=2mm, bottom=2mm,
    breakable
  }
}

% Environnement "définition encadrée"
\newtcolorbox{defbox}[2][]{mydefstyle,title=#2,#1}

\title{Constrained Pseudorandom Functions, Revisited}
\author{Julian Mouthon, Mario Razafinony}
\date{}

\begin{document}
\maketitle

\section{Définitions}

\begin{defbox}{Fonction pseudo-aléatoire (PRF)}

Une fonction pseudo-aléatoire
\[
F : \mathcal K \times D \rightarrow R
\]
est une fonction telle que, pour une clé secrète $K$, la fonction $F(K,\cdot)$ est
indiscernable d’une fonction réellement aléatoire
$G : D \rightarrow R$ pour tout adversaire efficace.
\end{defbox}

\begin{defbox}{Contrainte}
\[
C : D \rightarrow \{0,1\}.
\]

\[
C(x)=1 \text{ : « l’entrée est autorisée »} \qquad
C(x)=0 \text{ : « l’entrée est interdite »}.
\]
\end{defbox}

\begin{defbox}{CPRF}
Une fonction pseudo-aléatoire contrainte (CPRF) est donnée par quatre algorithmes efficaces :
\begin{itemize}
\item $\textsf{Setup}(1^\lambda) \to K$ (clé maître) : génère la clé secrète principale $K$.
\item $\textsf{Constrain}(K,C) \to K_C$ (clé contrainte) : produit une clé spéciale $K_C$ permettant
d’évaluer la fonction uniquement sur les entrées autorisées par $C$.
\item $\textsf{Eval}(K,x) \to y$ : évalue la fonction pseudo-aléatoire sur une entrée $x$ avec la clé maître.
\item $\textsf{EvalC}(K_C,x) \to y$ : évalue la fonction sur l’entrée $x$ avec la clé contrainte $K_C$.
\end{itemize}


Une CPRF est correcte si, pour toute clé $K$, toute contrainte $C$ et toute entrée $x$
telle que $C(x)=1$, on a
\[
\textsf{EvalC}(K_C,x)=\textsf{Eval}(K,x).
\]

Autrement dit, la clé contrainte permet d’évaluer la PRF exactement sur les entrées autorisées.
\end{defbox}

\section{Implémentation de la CPRF de BMO17}

La CPRF de BMO17 est basée sur l'itération successive d'une permutation à trappe, qui est une fonction bijective, que l'on notera $\pi$.

\begin{defbox}{Génération de la clé maîtresse}
La clé maîtresse sera composé des éléments :
\begin{itemize}
  \item $ST_0 \in \mathbb{Z}_N$
  \item $SK$ une clé RSA pour avoir la permutation $\pi_{SK}$
\end{itemize}
\end{defbox}

\begin{defbox}{Évaluation de la CPRF avec la clé maîtresse}
    
    Avec la clé maîtresse ($ST_0$, $SK$) et une entrée $c$, on peut évaluer la CPRF sur $c$ :
    \[
    F((SK, ST_0), c) = \pi_{SK}^{-c}(ST_0) 
    \]
  
\end{defbox}

\begin{defbox}{Génération de la clé contrainte}
  À partir de la clé maîtresse ($ST_0$, $SK$) et d'un entier $n$, la clé contrainte calculée sera composée des éléments :
  \begin{itemize}
    \item $PK$
    \item $ST_n$ $=$ $\pi_{SK}^{-n}(ST_0)$
    \item $n$
  \end{itemize}
\end{defbox}

\begin{defbox}{Évaluation de la CPRF avec la clé contrainte}
    
    Avec la clé contrainte ($PK$, $ST_n$, $n$) et une entrée $c$, on peut évaluer la CPRF si $c < n$ :
    \[
    F.Eval((PK, ST_n, n), c) = \pi_{PK}^{n-c}(ST_c) 
    \]
\end{defbox}
\end{document}

