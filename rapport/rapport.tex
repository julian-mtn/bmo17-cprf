\documentclass[11pt]{article}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{hyperref}
\usepackage{bookmark}
\usepackage{enumitem}
\usepackage{geometry}
\usepackage[many]{tcolorbox}
\geometry{margin=2.5cm}
% chktex-file 26
% chktex-file 13


\tcbset{
  mydefstyle/.style={
    colback=white,
    colframe=black,
    fonttitle=\bfseries,
    boxrule=0.8pt,
    arc=4pt,
    left=3mm, right=3mm, top=2mm, bottom=2mm,
    breakable
  }
}

% Environnement "définition encadrée"
\newtcolorbox{defbox}[2][]{mydefstyle,title=#2,#1}

\title{Constrained Pseudorandom Functions, Revisited}
\author{Julian Mouthon, Mario Razafinony}
\date{\today}

\usepackage{fancyhdr}
\setlength{\headheight}{13.59999pt}
\pagestyle{fancy}

\fancyhf{}

\fancyhead[L]{Projet CCA}
\fancyhead[R]{Sorbonne Université}
\fancyfoot[C]{\thepage}


\begin{document}
\maketitle

\section*{Introduction}

Ce projet s’inscrit dans le cadre de l’étude des fonctions pseudo-aléatoires contraintes
(\emph{Constrained Pseudorandom Functions}, CPRF), une extension des fonctions
pseudo-aléatoires classiques permettant de restreindre les évaluations à un sous-ensemble
d’entrées défini par une contrainte.

Dans un premier temps, nous présentons les notions fondamentales liées aux fonctions
pseudo-aléatoires et aux CPRFs, ainsi que la construction proposée par Bost, Minaud et
Ohrimenko en 2017 (BMO17).

Dans un second temps, nous nous intéressons aux travaux récents de Cheng et Jaeger
en 2025 (CJ25), qui mettent en évidence une attaque contre cette CPRF et proposent une variante
hachée assurant la sécurité dans un nouveau modèle. 

\newpage

\tableofcontents
\newpage

\section{Définitions}

\addcontentsline{toc}{subsection}{Fonction pseudo-aléatoire}
\begin{defbox}{Fonction pseudo-aléatoire (PRF)}

Une fonction pseudo-aléatoire
\[
F : \mathcal K \times D \rightarrow R
\]
est une fonction telle que, pour une clé secrète $K$, la fonction $F(K,\cdot)$ est
indiscernable d’une fonction réellement aléatoire
$G : D \rightarrow R$ pour tout adversaire efficace.
\end{defbox}

\addcontentsline{toc}{subsection}{Contrainte}
\begin{defbox}{Contrainte}

Une contrainte est un prédicat booléen
\[
C : D \rightarrow \{0,1\},
\]
qui partitionne le domaine $D$ en deux ensembles:
\begin{itemize}
\item les entrées \emph{autorisées}, telles que $C(x)=1$
\item les entrées \emph{interdites} (ou contraintes), telles que $C(x)=0$
\end{itemize}

Intuitivement, la contrainte spécifie l’ensemble des entrées sur lesquelles une clé
contrainte est autorisée à évaluer la fonction pseudo-aléatoire.

Ici, nous considérons principalement des contraintes de la forme
\[
C_n(x) = [x < n],
\]
qui autorisent toutes les entrées strictement inférieures à un seuil $n \in \mathbb{N}$.
\end{defbox}

\addcontentsline{toc}{subsection}{Fonction pseudo-aléatoire contrainte}
\begin{defbox}{Fonction pseudo-aléatoire contrainte (CPRF)}
Une fonction pseudo-aléatoire contrainte (CPRF) est donnée par quatre algorithmes efficaces:
\begin{itemize}
\item $\textsf{Setup}(1^\lambda) \to K$ (clé maître): génère la clé secrète principale $K$.
\item $\textsf{Constrain}(K,C) \to K_C$ (clé contrainte): produit une clé spéciale $K_C$ permettant
d’évaluer la fonction uniquement sur les entrées autorisées par $C$.
\item $\textsf{Eval}(K,x) \to y$ : évalue la fonction pseudo-aléatoire sur une entrée $x$ avec la clé maître.
\item $\textsf{EvalC}(K_C,x) \to y$ : évalue la fonction sur l’entrée $x$ avec la clé contrainte $K_C$.
\end{itemize}

Une CPRF est correcte si, pour toute clé $K$, toute contrainte $C$ et toute entrée $x$
telle que $C(x)=1$, on a
\[
\textsf{EvalC}(K_C,x)=\textsf{Eval}(K,x).
\]

Autrement dit, la clé contrainte permet d’évaluer la PRF exactement sur les entrées autorisées.
\end{defbox}

\section{Construction de la CPRF de BMO17}

\subsection{Propriétés}

La CPRF de BMO17 est basée sur l'itération successive d'une permutation à trappe,
c’est-à-dire une fonction bijective facile à calculer mais difficile à inverser sans information secrète.
On note cette permutation $\pi$.

\addcontentsline{toc}{subsubsection}{Clé maîtresse}
\begin{defbox}{Génération de la clé maîtresse}
La clé maîtresse est composée des éléments suivants :
\begin{itemize}
  \item $ST_0 \in \mathbb{Z}_N$, un état initial secret choisi aléatoirement
  \item $SK$, une clé secrète RSA définissant la permutation à trappe $\pi_{SK}$
\end{itemize}
La clé publique associée $PK$ permet uniquement de calculer la permutation directe $\pi$.
\end{defbox}

\addcontentsline{toc}{subsubsection}{Evaluation avec clé maîtresse}
\begin{defbox}{Evaluation de la CPRF avec la clé maîtresse}
    
Avec la clé maîtresse $(ST_0, SK)$ et une entrée $c$, on peut évaluer la CPRF sur $c$ par :
\[
F((SK, ST_0), c) = \pi_{SK}^{-c}(ST_0)
\]

L’évaluation consiste à appliquer $c$ fois l’inverse de la permutation à partir de l’état initial $ST_0$.
\end{defbox}

\addcontentsline{toc}{subsubsection}{Clé contrainte}
\begin{defbox}{Génération de la clé contrainte}
À partir de la clé maîtresse $(ST_0, SK)$ et d’un entier $n$, correspondant à la contrainte
$C(c) = [c < n]$, la clé contrainte est composée des éléments suivants :
\begin{itemize}
  \item $PK$, la clé publique associée à la permutation $\pi$
  \item $ST_n = \pi_{SK}^{-n}(ST_0)$
  \item $n$
\end{itemize}

La clé secrète $SK$ n’est pas incluse dans la clé contrainte.
\end{defbox}

\addcontentsline{toc}{subsubsection}{Évaluation avec clé contrainte}
\begin{defbox}{Évaluation de la CPRF avec la clé contrainte}
    
Avec la clé contrainte $(PK, ST_n, n)$ et une entrée $c$, l’évaluation est possible uniquement si
$c < n$.
Dans ce cas, la valeur de la CPRF est calculée comme suit :
\[
\textsf{EvalC}((PK, ST_n, n), c) = \pi_{PK}^{\,n-c}(ST_n)
\]

Cette valeur est égale à $F((SK, ST_0), c)$ par construction, ce qui assure la correction du schéma.
\end{defbox}



\subsection{Implémentation}

Nous utilisons la bibliothèque OpenSSL pour la gestion des grands entiers
(\texttt{BIGNUM}), les opérations modulaires et le calcul de hachage SHA-256.

L’aléa est sécurisé et est obtenu à partir de \texttt{/dev/urandom}, ce qui
permet de générer l’état initial $ST_0$ ainsi que les paramètres RSA de manière sûre.


\subsubsection{Permutation RSA}

La permutation à trappe utilisée dans BMO17 est défini à l’aide de RSA.
Nous implémentons la génération de clés RSA de taille 2048 bits, ainsi que l’évaluation
de la permutation dans les deux sens.

Plus précisément, la fonction publique correspond à:
\[
x \mapsto x^e \bmod N,
\]
tandis que l’inverse de la permutation est calculé via:
\[
x \mapsto x^d \bmod N.
\]

Afin de limiter les fuites par canaux auxiliaires, l’évaluation privée est réalisée à l’aide
de la fonction \texttt{BN\_mod\_exp\_mont\_consttime} d’OpenSSL, qui garantit un temps
d’exécution indépendant des données.


\subsubsection{Clé maîtresse}

La clé maîtresse de la CPRF est composée d’un état initial secret $ST_0$ et d’une clé
privée RSA. L’état initial est généré comme un entier aléatoire de 256 bits à partir de
\texttt{/dev/urandom}..

L’évaluation avec la clé maîtresse consiste à appliquer $c$ fois l’inverse de la permutation
RSA à partir de $ST_0$.

\subsubsection{Clé contrainte}

À partir de la clé maîtresse et d’un paramètre de contrainte $n$, nous dérivons une clé
contrainte composée de la clé publique RSA $(e, N)$ et de l’état
\[
ST_n = \pi^{-n}(ST_0).
\]

Cette clé permet ensuite d’évaluer la CPRF uniquement pour les entrées $c < n$ en
appliquant $(n-c)$ fois la permutation publique à partir de $ST_n$. La clé privée n’est
jamais incluse dans la clé contrainte, ce qui garantit que seules les évaluations autorisées
sont possibles.

\subsection{Tests d'amélioration}
\subsubsection{Permutation à trappe Rabin}

\paragraph{}La permutation de Rabin est une fonction cryptographique à trappe fondée sur la difficulté de la factorisation des entiers. Elle est conceptuellement plus simple que RSA et repose sur l'opération de mise au carré modulo un entier composé.

\begin{itemize}
\item\textbf{Génération de la clé :}

On choisit deux nombres premiers distincts $p$ et $q$ tels que :
\[
p \equiv q \equiv 3 \pmod{4}
\]

La clé publique est définie par :
\[
n = p \cdot q
\]

La clé privée est le couple $(p, q)$.

Cette condition sur $p$ et $q$ permet un calcul efficace des racines carrées modulo ces nombres premiers.

\item\textbf{Permutation de Rabin :}

La permutation de Rabin est la fonction :
\[
f : \mathbb{Z}_n \rightarrow \mathbb{Z}_n
\]
définie par :
\[
f(x) = x^2 \bmod n
\]

Cette fonction est facile à calculer, mais difficile à inverser sans connaître la factorisation de $n$.

\item\textbf{Inverser la permutation de Rabin :}

Inverser la permutation de Rabin revient à résoudre l'équation :
\[
x^2 \equiv y \pmod{n}
\]

Lorsque $n = p \cdot q$, cette équation admet exactement \textbf{quatre solutions distinctes} modulo $n$.

%\subsection{Résolution modulo p et q}

On commence par réduire le problème modulo $p$ et $q$ :
\[
\begin{cases}
x^2 \equiv y \pmod{p} \\
x^2 \equiv y \pmod{q}
\end{cases}
\]

Comme $p \equiv 3 \pmod{4}$, une racine carrée modulo $p$ est donnée par :
\[
r_p = y^{\frac{p+1}{4}} \bmod p
\]

De même, modulo $q$ :

\[
r_q = y^{\frac{q+1}{4}} \bmod q
\]

Les solutions sont donc: 

\begin{itemize}
  \item $X_0 = (r_p * q * q^{-1}_{\bmod p} + r_q * p * p^{-1}_{\bmod q}) \bmod n $

  \item $X_1 = (r_p * q * q^{-1}_{\bmod p} - r_q * p * p^{-1}_{\bmod q}) \bmod n$

  \item $X_2 = (-r_p * q * q^{-1}_{\bmod p} + r_q * p * p^{-1}_{\bmod q}) \bmod n$

  \item $X_3 = (-r_p * q * q^{-1}_{\bmod p} - r_q * p * p^{-1}_{\bmod q}) \bmod n$
\end{itemize}


\end{itemize}

\paragraph{Problème:}Laquelle de ces racines correspond au message original ?
\paragraph{}
La fonction \(f(x) = x^2 \bmod n\) n'est pas injective: chaque chiffré \(c\) a 4 pré-images.
Même avec la clé secrète (\(p,q\)), on peut calculer toutes les racines mais \textbf{pas déterminer directement celle qui correspond au message initial}.
Appliquer l'inverse \(n-c\) fois ou une autre manipulation n'assure pas de retrouver le message original.


\subsubsection{AES}
\paragraph{}
Le chiffrement AES applique une fonction bijective \(E_k(x)\) qui dépend de la clé \(k\).
Contrairement à \(x \mapsto x^2 \bmod n\), AES est injectif et chaque bloc chiffré a une \textbf{unique pré-image} pour une clé donnée.
Cependant, pour déchiffrer, il faut absolument connaître la clé \(k\) :
\begin{itemize}
    \item Sans la clé, l'attaquant ne peut pas inverser la permutation.
    \item AES reste sécurisé grâce à la clé secrète.
\end{itemize}


Donc l'utilisation d'AES comme permutation à trappe n'est pas adaptée pour notre CPRF.


\section{L'attaque CJ25}

\subsection{Résumé}

\paragraph{}L’attaque CJ25 exploite le fait qu'un attaquant peut reçevoir des évaluations et évaluer la valeur qu'il reçoit sur une clé contrainte.

\paragraph{}Plus précisément, l’adversaire commence par obtenir une évaluation de la fonction pseudo-aléatoire contrainte sur une entrée donnée $x$, 
c’est-à-dire une valeur $ST_x = F((SK, ST_0), x). $. À cet étape, l'attaquant ne connait pas encore si $ST_x$ est le résultat d'une fonction aléatoire ou non.

\paragraph{}Dans un second temps, il demandera une clé contrainte $(PK, ST_n, n)$ telle que l’entrée $x$ n'est pas contrainte $(x > n)$.
Avec une telle clé contrainte, au lieu de calculer $\pi_{PK}^{\,n-c}(ST_n)$, il calculera $\pi_{PK}^{\,n-c}(ST_x) = ST_a$.
Si l'attaquant retrouve $ST_a = ST_x$, il peut alors conclure que la valeur $ST_x$ est le résultat d'une fonction non aléatoire.

\paragraph{}Il est donc possible pour un attaquant d'avoir des informations sur certains résultats avec une probabilité de $1/N$ de trouver qu'un résultat n'est pas le résultat d'une fonction aléatoire, où $N$ est la taille de la permutation.

\subsection{Jeu de sécurité}

\subsection{Implémentation}

\section{CPRF hachée de CJ25}

\subsection{Résumé}

\subsection{Implémentation}


\section{Une preuve sur une définition des CPRF}


\end{document}
