\documentclass[11pt]{article}

% Encodage et langues
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
% Mathématiques
\usepackage{amsmath,amssymb}
% Hyperliens et PDF
\usepackage{lastpage}
\usepackage{hyperref}
\usepackage{bookmark}
% Listes
\usepackage{enumitem}
% Marges et mise en page
\usepackage[a4paper, margin=2.5cm]{geometry}
% Interligne et espacement
\usepackage{setspace}
\onehalfspacing             % interligne 1,5 pour un article scientifique
\setlength{\parindent}{0pt} % pas d'indentation
\setlength{\parskip}{6pt}   % espace vertical entre paragraphes
% Figures et TikZ
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{float}
\usetikzlibrary{decorations.pathreplacing,trees,calc}

% Couleurs et boîtes
\usepackage[many]{tcolorbox}
\tcbset{
  mydefstyle/.style={
    colback=white,
    colframe=black,
    fonttitle=\bfseries,
    boxrule=0.8pt,
    arc=4pt,
    left=3mm, right=3mm, top=5mm, bottom=5mm,
    breakable
  }
}
\newtcolorbox{defbox}[2][]{mydefstyle,title=#2,#1}

% Titres des sections
\usepackage{titlesec}
\titlespacing*{\section}{0pt}{1.5ex plus 1ex minus .2ex}{1ex plus .2ex}
\titlespacing*{\subsection}{0pt}{1ex plus .5ex minus .2ex}{0.5ex plus .2ex}
\titlespacing*{\subsubsection}{0pt}{0.8ex plus .3ex minus .1ex}{0.3ex plus .1ex}

% En-têtes et pieds de page
\usepackage{fancyhdr}
\setlength{\headheight}{14pt}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Constrained Pseudorandom Functions, Revisited}
\fancyhead[R]{Sorbonne Université}
\fancyfoot[C]{\thepage\ /\ \pageref{LastPage}}

% TikZ pour les états et flèches
\tikzset{
  state/.style={
    draw,
    rectangle,
    rounded corners,
    minimum height=8mm,
    minimum width=14mm,
    align=center,
    font=\small,
  },
  hashstate/.style={
    state,
    fill=red!20
  },
  arrow/.style={
    ->,
    thick
  }
}

%========================================================================================

\title{Constrained Pseudorandom Functions, Revisited}
\author{
\textbf{Julian Mouthon, Mario Razafinony}\\
\small Master 1 Cryptologie, Calcul haute-performance et Algorithmique\\
\small Sorbonne Université
}
\date{\today}

\begin{document}

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{./images/sorbonne.png}
\end{figure}


\maketitle

\section*{Introduction}

Ce projet s’intéresse aux fonctions pseudo-aléatoires contraintes
(\emph{Constrained Pseudorandom Functions}, CPRF), une extension des fonctions
pseudo-aléatoires classiques permettant de restreindre les évaluations à un sous-ensemble
d’entrées défini par une contrainte.

Dans un premier temps, nous présentons les notions fondamentales liées aux fonctions
pseudo-aléatoires et aux CPRFs, ainsi que la construction proposée par Bost, Minaud et
Ohrimenko en 2017 (BMO17).

Dans un second temps, nous nous intéressons aux travaux récents de Cheng et Jaeger
en 2025 (CJ25), qui mettent en évidence une attaque contre cette CPRF et proposent une variante
hachée assurant la sécurité face à un tel attaquant.\\\\



\small \textit{Le code source est disponible sur GitHub : 
\href{https://github.com/julian-mtn/bmo17-cprf.git}{https://github.com/julian-mtn/bmo17-cprf.git}}


\newpage

\tableofcontents
\newpage

\section{Définitions}

\addcontentsline{toc}{subsection}{Fonction pseudo-aléatoire}
\begin{defbox}{Fonction pseudo-aléatoire (PRF)}

Une fonction pseudo-aléatoire
\[
F : \mathcal K \times D \rightarrow R
\]
est une fonction telle que, pour une clé secrète $K$, la fonction $F(K,\cdot)$ est
indiscernable d’une fonction réellement aléatoire
$G : D \rightarrow R$ pour tout adversaire efficace.
\end{defbox}

\addcontentsline{toc}{subsection}{Contrainte}
\begin{defbox}{Contrainte}

Une contrainte est un prédicat booléen
\[
C : D \rightarrow \{0,1\},
\]
qui partitionne le domaine $D$ en deux ensembles:
\begin{itemize}
\item les entrées \emph{autorisées}, telles que $C(x)=1$
\item les entrées \emph{interdites} (ou contraintes), telles que $C(x)=0$
\end{itemize}

Intuitivement, la contrainte spécifie l’ensemble des entrées sur lesquelles une clé
contrainte est autorisée à évaluer la fonction pseudo-aléatoire.\\

Ici, nous considérons principalement des contraintes de la forme
\[
C_n(x) = [x < n],
\]
qui autorisent toutes les entrées strictement inférieures à un seuil $n \in \mathbb{N}$.
\end{defbox}

\addcontentsline{toc}{subsection}{Fonction pseudo-aléatoire contrainte}
\begin{defbox}{Fonction pseudo-aléatoire contrainte (CPRF)}
Une fonction pseudo-aléatoire contrainte (CPRF) est donnée par quatre algorithmes efficaces:
\begin{itemize}
\item $\textsf{Setup}(1^\lambda) \to K$ (clé maître): génère la clé secrète principale $K$.
\item $\textsf{Constrain}(K,C) \to K_C$ (clé contrainte): produit une clé spéciale $K_C$ permettant
d’évaluer la fonction uniquement sur les entrées autorisées par $C$.
\item $\textsf{Eval}(K,x) \to y$ : évalue la fonction pseudo-aléatoire sur une entrée $x$ avec la clé maître.
\item $\textsf{EvalC}(K_C,x) \to y$ : évalue la fonction sur l’entrée $x$ avec la clé contrainte $K_C$.
\end{itemize}

Une CPRF est correcte si, pour toute clé $K$, toute contrainte $C$ et toute entrée $x$
telle que $C(x)=1$, on a
\[
\textsf{EvalC}(K_C,x)=\textsf{Eval}(K,x).
\]

Autrement dit, la clé contrainte permet d’évaluer la PRF exactement sur les entrées autorisées.
\end{defbox}

\section{Construction de la CPRF de BMO17}

\subsection{Propriétés}

La CPRF de BMO17 est basée sur l'itération successive d'une permutation à trappe,
c’est-à-dire une fonction bijective facile à calculer mais difficile à inverser sans information secrète.
On note cette permutation $\pi$.

\addcontentsline{toc}{subsubsection}{Génération et structure de la clé maîtresse}
\begin{defbox}{Génération de la clé maîtresse}
La clé maîtresse est composée des éléments suivants :
\begin{itemize}
  \item $ST_0 \in \mathbb{Z}_N$, un état initial secret choisi aléatoirement
  \item $SK$, une clé secrète RSA définissant la permutation à trappe $\pi_{SK}$
\end{itemize}
La clé publique associée $PK$ permet uniquement de calculer la permutation directe $\pi$.
\end{defbox}

\addcontentsline{toc}{subsubsection}{Évaluation de la CPRF avec la clé maîtresse}
\begin{defbox}{Evaluation de la CPRF avec la clé maîtresse}
    
Avec la clé maîtresse $(ST_0, SK)$ et une entrée $c$, on peut évaluer la CPRF sur $c$ par :
\[
Eval((SK, ST_0), c) = \pi_{SK}^{-c}(ST_0)
\]

L’évaluation consiste à appliquer $c$ fois l’inverse de la permutation à partir de l’état initial $ST_0$.

\begin{center}
\begin{tikzpicture}[node distance=2.2cm]
  \node[state] (s0) {$ST_0$};
  \node[state, right of=s0] (s1) {$ST_1$};
  \node[right of=s1] (dots) {$\cdots$};
  \node[state, right of=dots] (sn) {$ST_n$};

  \draw[arrow] (s0) -- node[above] {$\pi^{-1}$} (s1);
  \draw[arrow] (s1) -- node[above] {$\pi^{-1}$} (dots);
  \draw[arrow] (dots) -- node[above] {$\pi^{-1}$} (sn);
\end{tikzpicture}
\end{center}

\end{defbox}



\addcontentsline{toc}{subsubsection}{Dérivation et structure de la clé contrainte}
\begin{defbox}{Génération de la clé contrainte}
À partir de la clé maîtresse $(ST_0, SK)$ et d’un entier $n$, correspondant à la contrainte
$C(c) = [c < n]$, la clé contrainte est composée des éléments suivants :
\begin{itemize}
  \item $PK$, la clé publique associée à la permutation $\pi$
  \item $ST_n = \pi_{SK}^{-n}(ST_0)$
  \item $n$
\end{itemize}

La clé secrète $SK$ n’est pas incluse dans la clé contrainte.
\end{defbox}

\addcontentsline{toc}{subsubsection}{Évaluation restreinte avec une clé contrainte}
\begin{defbox}{Évaluation de la CPRF avec la clé contrainte}
    
Avec la clé contrainte $(PK, ST_n, n)$ et une entrée $c$, l’évaluation est possible uniquement si
$c < n$.
Dans ce cas, la valeur de la CPRF est calculée comme suit :
\[
\textsf{EvalC}((PK, ST_n, n), c) = \pi_{PK}^{\,n-c}(ST_n)
\]

Cette valeur est égale à $Eval((SK, ST_0), c)$ par construction, ce qui assure la correction du schéma.

\begin{center}
\begin{tikzpicture}[node distance=2.2cm]
  \node[state] (sn) {$ST_n$};
  \node[state, right of=sn] (sn1) {$ST_{n-1}$};
  \node[right of=sn1] (dots) {$\cdots$};
  \node[state, right of=dots] (s0) {$ST_0$};

  \draw[arrow] (sn) -- node[above] {$\pi$} (sn1);
  \draw[arrow] (sn1) -- node[above] {$\pi$} (dots);
  \draw[arrow] (dots) -- node[above] {$\pi$} (s0);
\end{tikzpicture}
\end{center}

\end{defbox}



\subsection{Choix d’implémentation}

Nous utilisons la bibliothèque OpenSSL pour la gestion des grands entiers
(\texttt{BIGNUM}), les opérations modulaires et le hachage SHA-256.

L’aléa est sécurisé et est obtenu à partir de \texttt{/dev/urandom}, ce qui
permet de générer l’état initial $ST_0$ ainsi que les paramètres RSA de manière plus sûre.


\subsubsection{Implémentation de la permutation à trappe RSA}

La permutation à trappe utilisée dans BMO17 est défini à l’aide de RSA.
Nous implémentons la génération de clés RSA de taille 4096 bits, ainsi que l’évaluation
de la permutation dans les deux sens.

Plus précisément, la fonction publique correspond à:
\[
x \mapsto x^e \bmod N,
\]
tandis que l’inverse de la permutation est calculé via:
\[
x \mapsto x^d \bmod N.
\]

avec 

\[
x^{e \cdot d} = x \bmod N , \forall x \in \mathbb{Z}_N.
\] 

Afin de limiter les fuites par canaux auxiliaires, l’évaluation privée est réalisée à l’aide
de la fonction \texttt{BN\_mod\_exp\_mont\_consttime} d’OpenSSL, qui garantit un temps
d’exécution indépendant des données.


\subsubsection{Implémentation de la clé maîtresse et génération de l’état initial}

La clé maîtresse de la CPRF est composée d’un état initial secret $ST_0$ et d’une clé
privée RSA. L’état initial est généré comme un entier aléatoire de 256 bits à partir de
\texttt{/dev/urandom}..

L’évaluation avec la clé maîtresse consiste à appliquer $c$ fois l’inverse de la permutation
RSA à partir de $ST_0$.

\subsubsection{Implémentation de la dérivation des clés contraintes}

À partir de la clé maîtresse et d’un paramètre de contrainte $n$, nous dérivons une clé
contrainte composée de la clé publique RSA $(e, N)$ et de l’état
\[
ST_n = \pi^{-n}(ST_0).
\]

Cette clé permet ensuite d’évaluer la CPRF uniquement pour les entrées $c < n$ en
appliquant $(n-c)$ fois la permutation publique à partir de $ST_n$. La clé privée n’est
jamais incluse dans la clé contrainte, ce qui garantit que seules les évaluations autorisées
sont possibles.

\subsection{Étude de permutations alternatives à RSA}

\subsubsection{Permutation à trappe de Rabin}

\paragraph{}La permutation de Rabin est une fonction cryptographique à trappe fondée sur la difficulté de la factorisation des entiers. Elle est conceptuellement plus simple que RSA et repose sur l'opération de mise au carré modulo un entier composé.

\begin{itemize}
\item\textbf{Génération de la clé :}

On choisit deux nombres premiers distincts $p$ et $q$ tels que :
\[
p \equiv q \equiv 3 \pmod{4}
\]

La clé publique est définie par :
\[
n = p \cdot q
\]

La clé privée est le couple $(p, q)$.

Cette condition sur $p$ et $q$ permet un calcul efficace des racines carrées modulo ces nombres premiers.\\

\item\textbf{Permutation de Rabin :}

La permutation de Rabin est la fonction :
\[
f : \mathbb{Z}_n \rightarrow \mathbb{Z}_n
\]
définie par :
\[
f(x) = x^2 \bmod n
\]

Cette fonction est facile à calculer, mais difficile à inverser sans connaître la factorisation de $n$.\\

\item\textbf{Inverser la permutation de Rabin :}

Inverser la permutation de Rabin revient à résoudre l'équation :
\[
x^2 \equiv y \pmod{n}
\]

Lorsque $n = p \cdot q$, cette équation admet exactement \textbf{quatre solutions distinctes} modulo $n$.

%\subsection{Résolution modulo p et q}

On commence par réduire le problème modulo $p$ et $q$ :
\[
\begin{cases}
x^2 \equiv y \pmod{p} \\
x^2 \equiv y \pmod{q}
\end{cases}
\]

Comme $p \equiv 3 \pmod{4}$, une racine carrée modulo $p$ est donnée par :
\[
r_p = y^{\frac{p+1}{4}} \bmod p
\]

De même, modulo $q$ :

\[
r_q = y^{\frac{q+1}{4}} \bmod q
\]

Les solutions sont donc: 

\begin{itemize}
  \item $X_0 = (r_p * q * q^{-1}_{\bmod p} + r_q * p * p^{-1}_{\bmod q}) \bmod n $

  \item $X_1 = (r_p * q * q^{-1}_{\bmod p} - r_q * p * p^{-1}_{\bmod q}) \bmod n$

  \item $X_2 = (-r_p * q * q^{-1}_{\bmod p} + r_q * p * p^{-1}_{\bmod q}) \bmod n$

  \item $X_3 = (-r_p * q * q^{-1}_{\bmod p} - r_q * p * p^{-1}_{\bmod q}) \bmod n$
\end{itemize}


\end{itemize}

\paragraph{Problème:}Laquelle de ces racines correspond au message original ?
\paragraph{}
La fonction \(f(x) = x^2 \bmod n\) n'est pas injective: chaque chiffré \(c\) a 4 pré-images.
Même avec la clé secrète (\(p,q\)), on peut calculer toutes les racines mais \textbf{pas déterminer directement celle qui correspond au message initial}.
Appliquer l'inverse \(n-c\) fois n'assure pas de retrouver le message original.



\begin{figure}[H]
  \centering
\begin{tikzpicture}[
  grow=down,
  sibling distance=20mm,
  level distance=20mm,
  every node/.style={fill=red!20,draw=red!30, circle, rounded corners, align=center, minimum width=10mm},
  correct/.style={draw=green!30, fill=green!20},
  level label/.style={font=\small, anchor=west, align=left}
]

\node[correct] {$ST_0$}
  % Niveau 1
  child {node[correct] {$X_0$} 
    % Niveau 2
    child {node {$X_0$}} 
    child {node {$X_1$}}
    child {node[correct] {$X_2$} 
      % Niveau 3 
      child {node[correct] {$\dots$} 
        child {node[correct] {$ST_n$}}
        child {node {$X_1$}}
        child {node {$X_2$}}
        child {node {$X_3$}}
      }
      child {node {$X_1$}}
      child {node {$X_2$}}
      child {node {$X_3$}}
    }
    child {node {$X_3$}}
  }
  child {node {$X_1$}} 
  child {node {$X_2$}}
  child {node {$X_3$}};
\end{tikzpicture}
\caption{Arbre des pré-images dans la permutation de Rabin.}\label{fig:rabin-tree}
\end{figure}

\paragraph{Conclusion :}
La permutation de Rabin n'est pas adaptée pour notre CPRF car chaque valeur a quatre pré-images possibles. 
Même avec la clé privée, il est impossible de savoir laquelle correspond à l'entrée originale, ce qui empêche 
l'application répétée de l'inverse $(n-c)$ fois pour retrouver correctement le résultat de la CPRF.


\subsubsection{Permutation à trappe AES}
\paragraph{}
Le chiffrement AES applique une fonction bijective \(E_k(x)\) qui dépend de la clé \(k\).
Contrairement à \(x \mapsto x^2 \bmod n\), chaque bloc chiffré a une \textbf{unique pré-image} pour une clé donnée.
Cependant, pour déchiffrer, \textbf{il faut absolument connaître la clé k} :
\begin{itemize}
    \item Sans la clé, l'attaquant ne peut pas inverser la permutation.
    \item AES reste sécurisé grâce à la clé secrète.
\end{itemize}

\paragraph{}
Donc l'utilisation d'AES comme permutation à trappe n'est pas adaptée pour notre CPRF.


\section{L'attaque CJ25}

\subsection{Description générale et intuition de l’attaque}

\paragraph{}
L’attaque CJ25 exploite le fait qu’un attaquant peut obtenir une clé contrainte
permettant d’évaluer la fonction pseudo‑aléatoire sur un sous‑ensemble d’entrées,
tout en conservant l’accès à un oracle d’évaluation global.

\paragraph{}
Dans un premier temps, l’adversaire choisit un indice $n$ et demande à l’oracle une
clé contrainte $(PK, ST_n, n)$. Cette clé lui permet d’évaluer la fonction sur toute
entrée $x$ telle que $x > n$ à l’aide des permutations publiques associées.

Dans un second temps, l’adversaire interroge l’oracle d’évaluation sur une entrée
$x > n$ et obtient une valeur $ST_x$. À ce stade, l’attaquant ne sait pas si $ST_x$
provient d’une fonction pseudo‑aléatoire contrainte ou d’une fonction aléatoire.

À l’aide de la clé contrainte, l’attaquant applique successivement les permutations
publiques afin de calculer la valeur $\pi_{PK}^{x-n}(ST_x)$.
Si l'attaquant retrouve $ST_a = ST_x$, il peut alors conclure que la valeur $ST_x$ est le résultat d'une fonction pseudo‑aléatoire contrainte.

\paragraph{}Il est donc possible pour un attaquant d'avoir des informations sur la structure de la CPRF à partir de la clé contrainte et des évaluations obtenues, ce qui lui permet de distinguer une CPRF d'une fonction aléatoire avec une probabilité non négligeable.\\


\begin{figure}[H]
\centering
\begin{tikzpicture}[node distance=2.5cm]
  % Etats
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center] (st0) {$ST_0$};
  \node[right of=st0] (dots1) {$\dots$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=dots1] (stn) {$ST_n$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=stn] (stn1) {$ST_{n+1}$};
  \node[right of=stn1] (dots) {$\dots$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=dots] (stx) {$ST_x$};

  % Flèches directes avec π
  \draw[->, thick] (st0) -- node[above] {$\pi$} (dots1);
  \draw[->, thick] (dots1) -- node[above] {$\pi$} (stn);
  \draw[->, thick] (stn) -- node[above] {$\pi$} (stn1);
  \draw[->, thick] (stn1) -- node[above] {$\pi$} (dots);
  \draw[->, thick] (dots) -- node[above] {$\pi$} (stx);

  % Flèches de l'attaquant (en rouge, dashed)
\draw[
  decorate,
  decoration={brace, mirror, amplitude=6pt, raise=8pt},
  red
]
  (st0.south west) -- (stn.south east)
  node[midway, below=14pt, red] {zone contrainte};

\draw[
  decorate,
  decoration={brace, mirror, amplitude=6pt, raise=8pt},
  blue
]
  (stn1.south west) -- (stx.south east)
  node[midway, below=14pt, blue] {zone d'évaluation hors contrainte};
\end{tikzpicture}
\caption{Schéma général de l’attaque CJ25}
\end{figure}


\subsection{Modélisation du jeu de sécurité et avantage de l’attaquant}
\begin{defbox}{Jeu de sécurité pour les CPRF}
L'attaquant $\mathcal{A}$ interagit avec un oracle $O$ qui est soit une $CPRF$ soit une fonction aléatoire. 
L’objectif de l'attaquant est de distinguer les deux cas.
\begin{itemize}
\item \textbf{Phase 1 :} $\mathcal{A}$ demande une clé contrainte $K_C = (PK, ST_n, n)$ pour une contrainte $n$ de son choix, lui permettant d’évaluer la fonction sur un sous-ensemble d’entrées.
\item \textbf{Phase 2 :} $\mathcal{A}$ fait un nombre de requêtes d’évaluation à l’oracle $O$ sur des entrées $x > n$ pour obtenir des valeurs $ST_x$ non contraintes.
\item \textbf{Phase 3 :} $\mathcal{A}$ utilise les valeurs obtenues pour évaluer $ST_a = \pi_{PK}^{\,n-x}(ST_x)$ et compare avec $ST_n$.
\item \textbf{Décision :} $\mathcal{A}$ décide que $O$ est la $CPRF$ si $ST_a = ST_n$, sinon il décide que $O$ est une fonction aléatoire.
\end{itemize}
Dans le cas où $O$ est une $CPRF$, l'attaquant $\mathcal{A}$ retrouve toujours $ST_a = ST_n$, et il ne se trompe jamais. En revanche, si $O$ est une fonction aléatoire, la probabilité que $ST_a = ST_n$ est de $1/N$, où $N$ est la taille de l’espace de sortie de la fonction. Dans ce cas, l'attaquant se trompe avec une probabilité de $1/N$.
L'attaquant $\mathcal{A}$ gagne donc avec une probabilité de $1 - 1/N$ de distinguer correctement les deux cas, ce qui est non négligeable pour des tailles de $N$ raisonnables.\\

\begin{figure}[H]
  \centering
\begin{tikzpicture}[node distance=3cm]
  % Etats
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center] (stn) {$ST_n$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=stn] (stnp1) {$ST_{n+1}$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=stnp1] (stnp2) {$ST_{n+2}$};
  \node[right of=stnp2] (dots) {$\dots$};
  \node[draw, rectangle, rounded corners, minimum height=8mm, minimum width=14mm, align=center, right of=dots] (stx) {$ST_x$};

  % Flèches directes CPRF avec pi écrit au-dessus
  \draw[->, thick] (stn) -- node[above] {$\pi$} (stnp1);
  \draw[->, thick] (stnp1) -- node[above] {$\pi$} (stnp2);
  \draw[->, thick] (stnp2) -- node[above] {$\pi$} (dots);
  \draw[->, thick] (dots) -- node[above] {$\pi$} (stx);

  % Flèches de l'attaquant (en rouge, dashed) sous les cases
  \draw[->, thick, dashed, red] (stx.south) .. controls +(0,-2.2) and +(0,-2.2) .. 
    node[below, red, align=center] {Attaquant applique la permutation \\ pour vérifier $ST_a = ST_n$} (stn.south);

  \draw[->, thick, dashed, red] (stx.south) .. controls +(-0.5,-1.5) and +(0,-1.5) .. 
    node[below, red, align=center] {} (stnp1.south);

  \draw[->, thick, dashed, red] (stx.south) .. controls +(-0.2,-1) and +(0,-1) .. 
    node[below, red, align=center] {} (stnp2.south);

\end{tikzpicture}
\caption{Schéma des permutation de l'attaque dans la zone hors contrainte}
\end{figure}




\end{defbox}

\subsection{Mise en œuvre expérimentale de l’attaque}

Pour simuler le jeu de sécurité, nous avons mis en place une architecture client–serveur locale 
reposant sur TCP. Le serveur implémente l’oracle du jeu 
(évaluation et génération de clés contraintes), 
le client joue le rôle de l’attaquant (requêtes d’évaluation et de contrainte, tests, ...).


\subsubsection{Implémentation de l’oracle de sécurité}


L’oracle met à disposition deux interfaces accessibles à l’attaquant :
\begin{itemize}
    \item \texttt{EVAL(x)} : retourne une valeur associée à l’entrée $x$.\\
    En monde PRF, l’oracle retourne l’évaluation de la CPRF à l’aide de la clé maîtresse.\\
    En monde aléatoire, il retourne une valeur uniforme de même taille.

    \item \texttt{CONSTRAIN(n)} : retourne une clé contrainte associée à l’indice $n$,
    permettant l’évaluation de la fonction sur un sous‑ensemble d’entrées.
\end{itemize}


\subsubsection{Implémentation de l’attaquant et stratégie}

L’attaquant choisit un indice $n$ et demande à l’oracle la clé
contrainte correspondante. Cette clé lui permet d’évaluer la fonction sur des entrées
strictement supérieures à $n$.

Ensuite il effectue des requêtes \texttt{EVAL} sur des entrées
$x > n$. À partir des valeurs retournées par l’oracle et de la clé contrainte, il
applique les permutations publiques afin de tester la cohérence de la structure de la CPRF.

Si l’attaquant trouve une correspondance, il peut conclure que l’oracle implémente une CPRF plutôt qu’une fonction aléatoire.

\section{Renforcement de la CPRF par hachage}

Afin d'améliorer la sécurité de la construction de BMO17 face à l'attaque CJ25,
il est possible d'implémenter une version hachée de la CPRF.

\subsection{Principe général de la CPRF hachée}

L’idée est d’introduire une fonction de hachage cryptographique dans l'évaluation. 
L'attaquant pourra toujours évaluer la CPRF sur les entrées non contraintes, 
mais il ne pourra pas exploiter les résultats pour distinguer la CPRF d’une fonction aléatoire
car ceux-ci seront hachés de manière irréversible.\\

$\rightarrow$ \textbf{Le rôle de la fonction de hachage est de rendre impossible toute utilisation ou comparaison
via les permutations publiques.}

\begin{center}
\begin{tikzpicture}[node distance=4cm]

% CPRF normale
\node[state] (a0) {$ST_x$};
\node[state, right of=a0] (a1) {$ST_n$};
\draw[arrow] (a0) -- node[above] {$\pi^{x-n}$} (a1);
\node at ($(a0)!0.5!(a1)+(0,0.8)$) {\textbf{CPRF}};

% Hashed CPRF
\node[hashstate, below of=a0, node distance=2cm] (b0) {$H(ST_x)$};
\node[hashstate, right of=b0] (b1) {$H(ST_n)$};
\draw[dashed] (b0) -- node[above] {\large $\times$} (b1);
\node at ($(b0)!0.5!(b1)+(0,0.8)$) {\textbf{Hashed CPRF}};

\end{tikzpicture}
\end{center}

\subsubsection{Implémentation}

Nous avons implémenté deux versions de la CPRF hachée :

\begin{itemize}
  \item \textbf{CPRF hachée simple} : l’évaluation est effectuée normalement,
  puis le résultat est haché à l’aide de \texttt{SHA-256} avant d’être retourné.
    \begin{itemize}
      \item \texttt{$Eval_H(x)$}: retourne le hachage de l’évaluation sur l’entrée $x$ avec la clé maîtresse, c’est-à-dire $H(Eval((SK, ST_0), x))$.
      \item \texttt{$EvalC_H(n)$}: retourne le hachage de l’évaluation sur l’entrée $n$ avec la clé contrainte, c’est-à-dire $H(EvalC((PK, ST_n, n), c))$.
    \end{itemize}

  \item \textbf{CPRF hachée avec lazy sampling} : afin de se rapprocher du modèle
  théorique d’un oracle de hachage idéal utilisé dans l'article CJ25, nous avons également implémenté
  une version reposant sur le lazy sampling décrite dans la section suivante.
\end{itemize}


\subsection{Construction explicite de la CPRF hachée de Cheng et Jaeger}

Nous présentons ici la version hachée proposée dans l'article CJ25.\\

Notations utilisées :
\begin{itemize}
  \item $P$ : fonction de hachage idéale modélisée comme un oracle de hachage aléatoire.
  \item $\sigma_P$ : état interne de $P$ (initialement vide) qui mémorise les paires $(x,y)$.
  \item $\lambda$ : paramètre de sécurité (taille de la sortie de $P$).
  \item $k$ : clé secrète de la \textsf{CPRF}.
  \item $k_R$ : clé contrainte associée à un ensemble de restrictions $R$.
  \item $x$ : entrée de la fonction.
  \item $y \in \{0,1\}^{\lambda}$ : valeur de hachage associée à une entrée.
\end{itemize}

L'évaluation est définie par :

\[
\textsf{Hashed[CPRF].Eval}(1^\lambda, k, x)
\;=\;
\textsf{$P$.LazySampling}(1^\lambda, \textsf{CPRF.Eval}(1^\lambda, k, x) : \sigma_P).
\]
\[
\textsf{Hashed[CPRF].EvalC}(1^\lambda, k_R, R, x)
\;=\;
\textsf{$P$.LazySampling}(1^\lambda, \textsf{CPRF.EvalC}(1^\lambda, k_R, R, x) : \sigma_P).
\]


\begin{center}
  \begin{tabular}{l}
    \textbf{Lazy Sampling} \\
    \hline \\
    Chercher $x$ dans $\sigma_P$ \\
    Si $x \notin \sigma_P$ : \\
    \quad Choisir $y \leftarrow \{0,1\}^\lambda$ au hasard \\
    \quad Mémoriser $(x,y)$ \\
    Sinon : \\
    \quad Récupérer $y$ associé à $x$ \\
    Retourner $y$
  \end{tabular}
  
  \vspace{1ex}
  \textit{Algorithme de lazy sampling d'une primitive idéale.}
\end{center}





\subsection{Évaluation expérimentale et comparaison des attaques}

\paragraph{}Après avoir implémenté les différentes versions de la CPRF (normale, hachée avec SHA-256 et hachée avec lazy sampling), nous avons mené des expériences pour évaluer l’efficacité de l’attaque CJ25 contre chacune d’elles.
Les tests ont été réalisés en exécutant 100 requêtes d’évaluation pour chaque version, et en enregistrant le taux de succès de l’attaque à chaque étape.

\paragraph{}Dans la figure \ref{fig:stat1}, on constate les résultats sur les attaques sur la version non hachée de la CPRF. On observe que l'attaque CJ25 est très efficace contre la CPRF non hachée, avec une probabilité de succès proche de 1 dès les premières requêtes d'évaluation. Avec $N$ de l'ordre de $2^{4096}$, la probabilité de se tromper est de $1/N$, ce qui est pratiquement nul.
Le taux d'attaque réussie à 100\% s'explique par le fait que l'attaquant doit faire en espérance $N = 2^{4096}$ requêtes pour se tromper une fois.

\paragraph{}Sur les figures \ref{fig:stat2} et \ref{fig:stat3}, on a utilisé le même modèle d'attaque contre les versions hachées avec SHA-256 et avec le lazy sampling.
On observe que l'attaque est complètement inefficace, avec un taux de succès proche de 0.5, ce qui correspond à une attaque aléatoire car l'attaquant ne détecte jamais de CPRF et se trompe dans la moitié des cas.
Ces deux figures montrent aussi que le choix du hachage n'a pas d'impact significatif sur l'efficacité de l'attaque, ce qui confirme que l'introduction du hachage rend la structure de la CPRF indiscernable pour l'attaquant.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{./images/stat1.png}
  \caption{Attaque version non hachée}
  \label{fig:stat1}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{./images/stat2.png}
  \caption{Attaque version hachée avec SHA-256}
  \label{fig:stat2}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.95\textwidth]{./images/stat3.png}
  \caption{Attaque version hachée avec lazy sampling}
  \label{fig:stat3}
\end{figure}

\section{Comment lancer le programme}

\begin{center}
\begin{tabular}{|l|p{10cm}|}
\hline
\textbf{Commande} & \textbf{Description} \\
\hline
\texttt{make} & Compile le projet. \\
\hline
\texttt{./start.sh -n <size>} & Lance les tests avec la CPRF normale. \\
\hline
\texttt{./start.sh -h <size>} & Lance les tests avec la CPRF hachée. \\
\hline
\texttt{./start.sh -l <size>} & Lance les tests avec le lazy sampling. \\
\hline
\texttt{<size>} & Nombre de tests à exécuter. \\
\hline
\texttt{python3 display.py} & Trace les courbes à partir des résultats enregistrés dans \texttt{attack\_results.txt}. \\
\hline
\end{tabular}
\end{center}


\end{document}
